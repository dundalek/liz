;; == run hello
;; -*- clojure -*-
(const std (@import "std"))

(defn ^:pub ^!void main []
  (const stdout (.. std -io getStdOut outStream))
  (try (.print stdout "Hello, {}!\n" ["world"])))

;; == run hello_again
(const print (.. (@import "std") -debug -print))

(defn ^:pub ^void main []
  (print "Hello, world!\n" []))

;; == test comments

(const expect (.. (@import "std") -testing -expect))

(test "comments"
  ;; (expect false)
  (const x true) ; another comment
  (expect x))

;; == run values
;; Top-level declarations are order-independent:
(const print std.debug.print)
(const std (@import "std"))
(const os std.os)
(const expect std.testing.expect)

(defn ^:pub ^void main []
    ;; integers
    (const ^i32 one_plus_one (+ 1 1))
    (print "1 + 1 = {}\n" [one_plus_one])

    ;; floats
    (const ^f32 seven_div_three (/ 7.0 3.0))
    (print "7.0 / 3.0 = {}\n", [seven_div_three])

    ;; boolean
    (print "{}\n{}\n{}\n"
           [(and true false)
            (or true false,)
            (not true)])

    ;; optional
    (var ^"?[]const u8" optional_value nil)
    (expect (= optional_value nil))

    (print "\noptional 1\ntype: {}\nvalue: {}\n"
      [(@typeName (@TypeOf optional_value))
       optional_value])

    (set! optional_value "hi")
    (expect (not= optional_value null))

    (print "\noptional 2\ntype: {}\nvalue: {}\n"
      [(@typeName (@TypeOf optional_value))
       optional_value])

    ;; error union
    (var ^anyerror!i32 number_or_error error.ArgNotFound)

    (print "\nerror union 1\ntype: {}\nvalue: {}\n"
      [(@typeName (@TypeOf number_or_error))
       number_or_error])

    (set! number_or_error 1234)

    (print "\nerror union 2\ntype: {}\nvalue: {}\n"
      [(@typeName (@TypeOf number_or_error))
       number_or_error]))

;; == test string literals
(const expect (.. (@import "std") -testing -expect))
(const mem (.. (@import "std") -mem))

(test "string literals"
  (const bytes "hello")
  (expect (= (@TypeOf bytes) (zig* "*const [5:0]u8")))
  (expect (= bytes.len 5))
  (expect (= (aget bytes 1) \e))
  (expect (= (aget bytes 5) 0))
  (expect (= \e \u0065));
  (expect (= 0x1f4a9 128169))
  ; (expect (= \ðŸ’¯ 128175));
  (expect (.eql mem u8 "hello" "h\u0065llo")))

;; == test namespaced_global.zig
(const std (@import "std"))
(const expect std.testing.expect)

(test "namespaced global variable"
  (expect (= (foo) 1235))
  (expect (= (foo) 1236)))

(defn ^i32 foo []
  (const S (struct
             (var ^i32 x 1234)))
  (+= S.x 1)
  (return S.x))

;; == test Thread Local Variables
(const std (@import "std"))
(const expect std.testing.expect)

(var ^:threadlocal ^i32 x 1234)

(test "thread local storage"
  (const thread1 (try (std.Thread.spawn {} testTls)))
  (const thread2 (try (std.Thread.spawn {} testTls)))
  (testTls {})
  (.wait thread1)
  (.wait thread2))

(defn ^void testTls [^void context]
  (expect (= x 1234))
  (+= x 1)
  (expect (= x 1235)))

;; == test comptime variables
(const std (@import "std"))
(const expect std.testing.expect)

(test "comptime vars"
  (var ^i32 x 1)
  (var ^:comptime ^i32 y 1)

  (+= x 1)
  (+= y 1)

  (expect (= x 2))
  (expect (= y 2))

  (when (not= y 2)
    ;; This compile error never triggers because y is a comptime variable,)
    ;; and so `y != 2` is a comptime value, and this if is statically evaluated.)
    (@compileError "wrong y value")))

;; == test Arrays
(const expect (.. (@import "std") -testing -expect))
(const mem (.. (@import "std") -mem))

;; array literal
(const message ^"[_]u8" [\h \e \l \l \o])

;; get the size of an array
(comptime
  (expect (= message.len 5)))

;; A string literal is a pointer to an array literal
(const same_message "hello")

(comptime
  (expect (.eql mem u8 (& message) same_message)))

(test "iterate over an array"
  (var ^usize sum 0)
  (for [byte message]
    (+= sum byte))
  (expect (= sum (+ \h \e (* \l 2) \o))))

;; modifiable array
(var ^"[100]i32" some_integers undefined)

(test "modify an array"
  (for [[*item, i] some_integers]
      (set! item.* (@intCast i32 i)))
  (expect (= (aget some_integers 10) 10))
  (expect (= (aget some_integers 99) 99)))

;; array concatenation works if the values are known
;; at compile time
(const part_one ^"[_]i32" [1, 2, 3, 4])
(const part_two ^"[_]i32" [5, 6, 7, 8])
(const all_of_it (++ part_one part_two))
(comptime
  (expect (.eql mem i32 (& all_of_it) (& ^"[_]i32" [1, 2, 3, 4, 5, 6, 7, 8]))))

;; remember that string literals are arrays
(const hello "hello")
(const world "world")
(const hello_world (++ hello " " world))
(comptime
  (expect (.eql mem u8 hello_world "hello world")))

;; ** does repeating patterns
(const pattern (** "ab" 3))
(comptime
  (expect (.eql mem u8 pattern "ababab")))

;; initialize an array to zero
(const all_zero (** ^"[_]u16" [0] 10))
(comptime
  (expect (= all_zero.len 10))
  (expect (= (aget all_zero 5) 0)))

;; use compile-time code to initialize an array
(var fancy_array
  (block :init
    (var ^"[10]Point" initial_value undefined)
    (for [[*pt, i] initial_value]
      (set! pt.* ^Point{:x (@intCast i32 i)
                        :y (* (@intCast i32 i) 2)}))
    (break :init initial_value)))

(const Point
  (struct
    ^i32 x
    ^i32 y))

(test "compile-time array initalization"
  (expect (= (.-x (aget fancy_array 4)) 4))
  (expect (= (.-y (aget fancy_array 4)) 8)))

;; call a function to initialize an array
(var more_points (-> ^"[_]Point" [(makePoint 3)]
                     (** 10)))
(defn ^Point makePoint [^i32 x]
  (return ^Point {:x x,
                  :y (* x 2)}))

(test "array initialization with function calls"
  (expect (= (.-x (aget more_points 4)) 3))
  (expect (= (.-y (aget more_points 4)) 6))
  (expect (= more_points.len 10)))

;; == test infer_list_literal.zig
(const std (@import "std"))
(const expect std.testing.expect)

(test "fully anonymous list literal"
  (dump [(@as u32 1234), (@as f64 12.34), true, "hi"]))

(defn ^void dump [^var args]
  (expect (= (.-0 args) 1234))
  (expect (= (.-1 args) 12.34))
  (expect (.-2 args))
  (expect (= (aget (.-3 args) 0) \h))
  (expect (= (aget (.-3 args) 1) \i)))

;; == test multidimensional.zig
(const std (@import "std"))
(const expect std.testing.expect)

(const mat4x4 ^"[4][4]f32" [^"[_]f32" [1.0, 0.0, 0.0, 0.0]
                            ^"[_]f32" [0.0, 1.0, 0.0, 1.0]
                            ^"[_]f32" [0.0, 0.0, 1.0, 0.0]
                            ^"[_]f32" [0.0, 0.0, 0.0, 1.0]])

(test "multidimensional arrays"
  ;; Access the 2D array by indexing the outer array, and then the inner array.
  (expect (= (aget mat4x4 1 1) 1.0))

  ;; Here we iterate with for loops.
  (for [[row, row_index] mat4x4]
    (for [[cell, column_index] row]
      (when (= row_index column_index)
        (expect (= cell 1.0))))))

;; == test volatile
(const expect (.. (@import "std") -testing -expect))

(test "volatile"
  (const mmio_ptr (@intToPtr (zig* "*volatile u8") 0x12345678))
  (expect (= (@TypeOf mmio_ptr) (zig* "*volatile u8"))))

;; == test pointer casting
(const std (@import "std"))
(const expect std.testing.expect)

(test "pointer casting"
  (const ^{:align "@alignOf(u32)"} bytes ^"[_]u8" [0x12, 0x12, 0x12, 0x12])
  (const u32_ptr (@ptrCast (zig* "*const u32") (& bytes)))
  (expect (= u32_ptr.* 0x12121212))

  ;; Even this example is contrived - there are better ways to do the above than
  ;; pointer casting. For example, using a slice narrowing cast:
  (const u32_value (-> (.bytesAsSlice std.mem u32 (slice bytes 0))
                       (aget 0)))
  (expect (= u32_value 0x12121212))

  ;; And even another way, the most straightforward way to do it:
  (expect (= (@bitCast u32 bytes) 0x12121212)))

(test "pointer child type"
  ;; pointer types have a `child` field which tells you the type they point to.
  (expect (= (.. (@typeInfo *u32) -Pointer -child) u32)))

;; == test structs.zig
;; Declare a struct.
;; Zig gives no guarantees about the order of fields and the size of
;; the struct but the fields are guaranteed to be ABI-aligned.
(const Point (struct ^f32 x
                     ^f32 y))

;; Maybe we want to pass it to OpenGL so we want to be particular about
;; how the bytes are arranged.
(const Point2 (^:packed struct ^f32 x
                               ^f32 y))

;; Declare an instance of a struct.
(const p ^Point {:x 0.12
                 :y 0.34})

;; Maybe we're not ready to fill out some of the fields.
(var p2 ^Point {:x 0.12
                 :y undefined})

;; Structs can have methods
;; Struct methods are not special, they are only namespaced
;; functions that you can call with dot syntax.
(const Vec3
  (struct
    ^f32 x
    ^f32 y
    ^f32 z
    (fn ^:pub ^Vec3 init [^f32 x ^f32 y ^f32 z]
      (return ^Vec3 {:x x
                     :y y
                     :z z}))

    (fn ^:pub ^f32 dot [^Vec3 self ^Vec3 other]
      (return (+ (* self.x other.x)
                 (* self.y other.y)
                 (* self.z other.z))))))

(const expect (.. (@import "std") -testing -expect))
(test "dot product"
    (const v1 (Vec3.init 1.0, 0.0, 0.0))
    (const v2 (Vec3.init 0.0, 1.0, 0.0))
    (expect (= (.dot v1 v2) 0.0))

    ;; Other than being available to call with dot syntax, struct methods are
    ;; not special. You can reference them as any other declaration inside
    ;; the struct:
    (expect (= (Vec3.dot v1 v2) 0.0)))

;; Structs can have global declarations.
;; Structs can have 0 fields.
(const Empty
  (struct
    (const ^:pub PI 3.14)))

(test "struct namespaced variable"
    (expect (= Empty.PI 3.14))
    (expect (= (@sizeOf Empty) 0))

    ;; you can still instantiate an empty struct
    (const does_nothing ^Empty {}))

;; struct field order is determined by the compiler for optimal performance.
;; however, you can still calculate a struct base pointer given a field pointer:
(defn ^void setYBasedOnX [^*f32 x ^f32 y]
  (const point (@fieldParentPtr Point "x" x))
  (set! point.y y))

(test "field parent pointer"
  (var point ^Point {:x 0.1234
                      :y 0.5678})

  (setYBasedOnX (& point.x) 0.9)
  (expect (= point.y 0.9)))

;; You can return a struct from a function. This is how we do generics
;; in Zig:
(defn ^type LinkedList [^:comptime ^type T]
  (return (struct
            (const ^:pub Node
              (struct
                ^?*Node prev
                ^?*Node next
                ^T data))

            ^?*Node first
            ^?*Node last
            ^usize len)))

(test "linked list"
  ;; Functions called at compile-time are memoized. This means you can
  ;; do this:
  (expect (= (LinkedList i32) (LinkedList i32)))

  (var list ^"LinkedList(i32)"
    {:first nil
     :last nil
     :len 0})

  (expect (= list.len 0))

  ;; Since types are first class values you can instantiate the type
  ;; by assigning it to a variable:
  (const ListOfInts (LinkedList i32))
  (expect (= ListOfInts (LinkedList i32)))

  (var node ^ListOfInts.Node
    {:prev nil
     :next nil
     :data 1234})

  (var list2 ^"LinkedList(i32)"
    {:first (& node)
     :last (& node)
     :len 1})

  (expect (= list2.first.?.data 1234)))

;; == test Default Field Values
(const Foo
  (struct
    ^i32 ^{:default 1234} a
    ^i32 b))

(test "default struct initialization fields"
    (const x ^Foo {:b 5})
    (when (not= (+ x.a x.b) 1239)
      (@compileError "it's even comptime known!")))

;; == run struct_name.zig
(const std (@import "std"))

(defn ^:pub ^void main []
    (const Foo (struct))
    (.print std.debug "variable: {}\n", [(@typeName Foo)])
    (.print std.debug "anonymous: {}\n", [(@typeName (struct))])
    (.print std.debug "function: {}\n", [(@typeName (List i32))]))

(defn ^type List [^:comptime ^type T]
  (return (struct ^T x)))

;; == test enums.zig
(const expect (.. (@import "std") -testing -expect))
(const mem (.. (@import "std") -mem))

;; Declare an enum.
(const Type
  (enum Ok
        NotOk))

;; Declare a specific instance of the enum variant.
(const c Type.Ok)

;; If you want access to the ordinal value of an enum, you
;; can specify the tag type.
(const Value
  ^u2 (enum Zero
            One
            Two))

;; Now you can cast between u2 and Value.
;; The ordinal value starts from 0, counting up for each member.
(test "enum ordinal value"
    (expect (= (@enumToInt Value.Zero) 0))
    (expect (= (@enumToInt Value.One) 1))
    (expect (= (@enumToInt Value.Two) 2)))

;; You can override the ordinal value for an enum.
(const Value2 ^u32
  (enum (set! Hundred 100)
        (set! Thousand 1000)
        (set! Million 1000000)))

(test "set enum ordinal value"
  (expect (= (@enumToInt Value2.Hundred) 100))
  (expect (= (@enumToInt Value2.Thousand) 1000))
  (expect (= (@enumToInt Value2.Million) 1000000)))

;; Enums can have methods, the same as structs and unions.
;; Enum methods are not special, they are only namespaced
;; functions that you can call with dot syntax.
(const Suit
  (enum Clubs
        Spades
        Diamonds
        Hearts

        (fn ^:pub ^bool isClubs [^Suit self]
          (return (= self Suit.Clubs)))))

(test "enum method"
  (const p Suit.Spades)
  (expect (not (.isClubs p))))

;; An enum variant of different types can be switched upon.
(const Foo
  (enum String
        Number
        None))

(test "enum variant switch"
  (const p Foo.Number)
  (const what_is_it
    (case p
      Foo.String "this is a string"
      Foo.Number "this is a number"
      Foo.None "this is a none"))

  (expect (.eql mem u8 what_is_it "this is a number")))

;; @TagType can be used to access the integer tag type of an enum.
(const Small
  (enum One
        Two
        Three
        Four))

(test "@TagType"
  (expect (= (@TagType Small) u2)))

;; @typeInfo tells us the field count and the fields names:
(test "@typeInfo"
  (expect (= (.-Enum.fields.len (@typeInfo Small)) 4))
  (expect (.eql mem u8
                (-> (@typeInfo Small) .-Enum .-fields (aget 1) .-name)
                "Two")))

;; @tagName gives a []const u8 representation of an enum value:
(test "@tagName"
  (expect (.eql mem u8 (@tagName Small.Three) "Three")))

;; == test Enum Literals
(const std (@import "std"))
(const expect std.testing.expect)

(const Color
  (enum Auto
        Off
        On))

(test "enum literals"
  (const ^Color color1 .Auto)
  (const color2 Color.Auto)
  (expect (= color1 color2)))

(test "switch using enum literals"
  (const color Color.On)
  (const result
    (case color
      .Auto false
      .On true
      .Off false))

  (expect result))

;; == test Non-exhaustive enum
(const std (@import "std"))
(const expect std.testing.expect)

(const Number
  ^u8 (enum
        One
        Two
        Three
        _))

(test "switch on non-exhaustive enum"
  (const number Number.One)
  (const result
    (case number
      .One true
      [.Two .Three] false
      _ false))

  (expect result)
  (const is_one
    (case number
      .One true
      false))

  (expect is_one))

;; == test union
(const std (@import "std"))
(const expect std.testing.expect)

(const Payload
  (union ^i64 Int
         ^f64 Float
         ^bool Bool))

(test "simple union"
  (var payload ^Payload {:Int 1234})
  (expect (= payload.Int 1234))
  (set! payload ^Payload {:Float 12.34})
  (expect (= payload.Float 12.34)))

;; == test Tagged union
(const std (@import "std"))
(const expect std.testing.expect)

(const ComplexTypeTag
  (enum Ok
        NotOk))

(const ComplexType ^ComplexTypeTag
  (union
    ^u8 Ok
    ^void NotOk))

(test "switch on tagged union"
  (const c ^ComplexType {:Ok 42})
  (expect (= (@as ComplexTypeTag c) ComplexTypeTag.Ok))

  (case c
    ComplexTypeTag.Ok (bind value
                        (expect (= value 42)))
    ComplexTypeTag.NotOk unreachable))

(test "@TagType"
  (expect (= (@TagType ComplexType) ComplexTypeTag)))

(test "coerce to enum"
  (const c1 ^ComplexType {:Ok 42})
  (const c2 ComplexType.NotOk)

  (expect (= c1 .Ok))
  (expect (= c2 .NotOk)))

;; == test Union method
(const std (@import "std"))
(const expect std.testing.expect)

(const Variant
  ^enum (union
          ^i32 Int
          ^bool Bool

          ;; void can be omitted when inferring enum tag type.
          None

          (fn ^bool truthy [^Variant self]
            (return (case self
                      Variant.Int (bind x_int (not= x_int 0))
                      Variant.Bool (bind x_bool x_bool)
                      Variant.None false)))))

(test "union method"
  (var v1 ^Variant {:Int 1})
  (var v2 ^Variant {:Bool false})

  (expect (.truthy v1))
  (expect (not (.truthy v2))))

;; == test block separate scopes
(test "separate scopes"
  (do
    (const pi 3.14))
  (do
    (var ^bool pi true)))

;; == test switch
(const std (@import "std"))
(const expect std.testing.expect)

(test "switch simple"
  (const ^u64 a 10)
  (const ^u64 zz 103)

  ;; All branches of a switch expression must be able to be coerced to a
  ;; common type.
  ;;
  ;; Branches cannot fallthrough. If fallthrough behavior is desired combine
  ;; the cases and use an if.
  (const b
    (case a
      ;; Multiple cases can be combined via a ''
      [1 2 3] 0

      ;; Ranges can be specified using the ... syntax. These are inclusive
      ;; both ends.
      (range 5 100) 1

      ;; Branches can be arbitrarily complex.
      101 (block :blk
            (const ^u64 c 5)
            (break :blk (* c (+ 2 1))))

      ;; Switching on arbitrary expressions is allowed as long as the
      ;; expression is known at compile-time.
      zz zz
      (comptime (block :blk
                  (const ^u32 d 5)
                  (const ^u32 e 100)
                  (break :blk (+ d e))))
      107

      ;; The else branch catches everything not already captured.
      ;; Else branches are mandatory unless the entire range of values
      ;; is handled.
      9))

  (expect (= b 1)))

;; Switch expressions can be used outside a function:
(const os_msg
  (case std.Target.current.os.tag
    .linux "we found a linux user"
    "not a linux user"))

;; Inside a function switch statements implicitly are compile-time
;; evaluated if the target expression is compile-time known.
(test "switch inside function"
  (case std.Target.current.os.tag
    .fuchsia (do
               ;; On an OS other than fuchsia block is not even analyzed
               ;; so this compile error is not triggered.
               ;; On fuchsia this compile error would be triggered.
               (@compileError "fuchsia not supported"))
    (do)))

;; == test switch tagged union
(const expect (.. (@import "std") -testing -expect))

(test "switch on tagged union"
  (const Point
    (struct ^u8 x
            ^u8 y))

  (const Item
    ^enum (union
            ^u32 A
            ^Point C
            D
            ^u32 E))

  (var a ^Item{:C ^Point{:x 1 :y 2}})

  ;; Switching on more complex enums is allowed.
  (const b
    (case a
      ;; A capture group is allowed on a match and will return the enum
      ;; value matched. If the payload types of both cases are the same
      ;; they can be put into the same switch prong.
      [Item.A Item.E] (bind item item)

      ;; A reference to the matched value can be obtained using `*` syntax.
      Item.C (bind *item (block :blk
                           (+= item.*.x  1)
                           (break :blk 6)))
      ;; No else is required if the types cases was exhaustively handled
      Item.D 8))

  (expect (= b 6))
  (expect (= a.C.x 2)))

;; == test while basic
(const expect (.. (@import "std") -testing -expect))

(test "while basic"
  (var ^usize i 0)
  (while (< i 10)
    (+= i 1))
  (expect (= i 10)))

;; == test while break
(const expect (.. (@import "std") -testing -expect))

(test "while break"
  (var ^usize i 0)
  (while true
    (if (= i 10)
      (break))
    (+= i 1))
  (expect (= i 10)))

;; == test while continue
(const expect (.. (@import "std") -testing -expect))

(test "while continue"
  (var ^usize i 0)
  (while true
    (+= i 1)
    (when (< i 10)
      (continue))
    (break))
  (expect (= i 10)))

;; == test while continue expression
(const expect (.. (@import "std") -testing -expect))

(test "while loop continue expression"
  (var ^usize i 0)
  (while-step (< i 10) (+= i 1))
  (expect (= i 10)))

(test "while loop continue expression, more complicated"
  (var ^usize i 1)
  (var ^usize j 1)
  (while-step (< (* i j) 2000)
              (do (*= i 2) (*= j 3))
    (const my_ij (* i j))
    (expect (< my_ij 2000))))

;; == test while else
(const expect (.. (@import "std") -testing -expect))

(test "while else"
  (expect (rangeHasNumber 0 10 5))
  (expect (not (rangeHasNumber 0 10 15))))

(defn ^bool rangeHasNumber [^usize begin ^usize end ^usize number]
  (var i begin)
  (return
    (else (while-step
           (< i end)
           (+= i 1)
           (when (= i number)
             (break true)))
          false)))

;; == test Labeled while
(test "nested break"
  (block :outer
    (while true
      (while true
        (break :outer)))))

(test "nested continue"
  (var ^usize i 0)
  (block :outer
    (while-step (< i 10) (+= i 1)
      (while true
        (continue :outer)))))

;; == test while with Optionals
(const expect (.. (@import "std") -testing -expect))

(test "while null capture"
  (var ^u32 sum1 0)
  (set! numbers_left 3)
  (while (eventuallyNullSequence)
    (bind value
      (+= sum1 value)))
  (expect (= sum1 3))

  (var ^u32 sum2 0)
  (set! numbers_left 3)
  (-> (while (eventuallyNullSequence)
        (bind value
          (+= sum2 value)))
      (else
       (expect (= sum2 3)))))

(var ^u32 numbers_left undefined)
(defn ^?u32 eventuallyNullSequence []
  (return (if (= numbers_left 0)
            null
            (block :blk
              (-= numbers_left 1)
              (break :blk numbers_left)))))

;; == test while with Error Unions
(const expect (.. (@import "std") -testing -expect))

(test "while error union capture"
    (var ^u32 sum1 0)
    (set! numbers_left 3)
    (-> (while (eventuallyErrorSequence)
          (bind value
            (+= sum1 value)))
        (else
         (bind err
           (expect (= err error.ReachedZero))))))

(var ^u32 numbers_left undefined)
(defn ^anyerror!u32 eventuallyErrorSequence []
  (return (if (= numbers_left 0)
            error.ReachedZero
            (block :blk
              (-= numbers_left 1)
              (break :blk numbers_left)))))

;; == test inline while
(const expect (.. (@import "std") -testing -expect))

(test "inline while loop"
  (var ^:comptime i 0)
  (var ^usize sum 0)
  (inline
    (while-step (< i 3) (+= i 1)
      (const T (case i
                 0 f32
                 1 i8
                 2 bool
                 unreachable))
      (+= sum (typeNameLength T))))
  (expect (= sum 9)))

(defn ^usize typeNameLength [^:comptime ^type T]
  (return (.-len (@typeName T))))

;; == test for
(const expect (.. (@import "std") -testing -expect))

(test "for basics"
  (const items ^"[_]i32" [4 5 3 4 0])
  (var ^i32 sum 0)
  ;; For loops iterate over slices and arrays.
  (for [value items]
    ;; Break and continue are supported.
    (when (= value 0)
      (continue))
    (+= sum value))
  (expect (= sum 16))

  ;; To iterate over a portion of a slice reslice.
  (for [value (slice items 0 1)]
    (+= sum value))
  (expect (= sum 20))

  ;; To access the index of iteration specify a second capture value.
  ;; This is zero-indexed.
  (var ^i32 sum2 0)
  (for [[value i] items]
    (expect (= (@TypeOf i) usize))
    (+= sum2 (@intCast i32 i)))

  (expect (= sum2 10)))

(test "for reference"
  (var items ^"[_]i32" [3 4 2])

  ;; Iterate over the slice by reference by
  ;; specifying that the capture value is a pointer.
  (for [*value items]
    (+= value.* 1))

  (expect (= (aget items 0) 4))
  (expect (= (aget items 1) 5))
  (expect (= (aget items 2) 3)))

(test "for else"
  ;; For allows an else attached to it the same as a while loop.
  (var items ^"[_]?i32" [3 4 nil 5])

  ;; For loops can also be used as expressions.
  ;; Similar to while loops when you break from a for loop the else branch is not evaluated.
  (var ^i32 sum 0)
  (const result
    (-> (for [value items]
          (when (not= value nil)
            (+= sum value.?)))
        (else (block :blk
                (expect (= sum 12))
                (break :blk sum)))))
  (expect (= result 12)))

;; == test Labeled for
(const std (@import "std"))
(const expect std.testing.expect)

(test "nested break"
  (var ^usize count 0)
  (block :outer
    (for [_ ^"[_]i32" [1 2 3 4 5]]
      (for [_ ^"[_]i32" [1 2 3 4 5]]
        (+= count 1)
        (break :outer))))
  (expect (= count 1)))


(test "nested continue"
  (var ^usize count 0)
  (block :outer
    (for [_ ^"[_]i32" [1 2 3 4 5 6 7 8]]
      (for [_ ^"[_]i32" [1 2 3 4 5]]
        (+= count 1)
        (continue :outer))))
  (expect (= count 8)))

;; == test Inline for
(const expect (.. (@import "std") -testing -expect))

(test "inline for loop"
  (const nums ^"[_]i32" [2 4 6])
  (var ^usize sum 0)
  (inline
   (for [i nums]
      (const T (case i
                 2 f32
                 4 i8
                 6 bool
                 unreachable))
      (+= sum (typeNameLength T))))
  (expect (= sum 9)))

(defn ^usize typeNameLength [^:comptime ^type T]
  (return (.-len (@typeName T))))

;; == test if

;; If expressions have three uses corresponding to the three types:
;; * bool
;; * ?T
;; * anyerror!T

(const expect (.. (@import "std") -testing -expect))

(test "if expression"
  ;; If expressions are used instead of a ternary expression.
  (const ^u32 a 5)
  (const ^u32 b 4)
  (const result (if (not= a b) 47 3089))
  (expect (= result 47)))

(test "if boolean"
  ;; If expressions test boolean conditions.
  (const ^u32 a 5)
  (const ^u32 b 4)
  (cond
    (not= a b) (expect true)
    (= a 9) (unreachable)
    :else (unreachable)))

(test "if optional"
  ;; If expressions test for null.

  (const ^?u32 a 0)
  (if a
    (bind value
      (expect (= value 0)))
    (unreachable))

  (const ^?u32 b nil)
  (if b
    (bind value (unreachable))
    (expect true))

  ;; The else is not required.
  (if a
    (bind value
      (expect (= value 0))))

  ;; To test against null only use the binary equality operator.
  (if (= b nil)
    (expect true))

  ;; Access the value by reference using a pointer capture.
  (var ^?u32 c 3)
  (if c
    (bind *value
      (set! value.* 2)))

  (if c
    (bind value
      (expect (= value 2)))
    (unreachable)))

(test "if error union"
  ;; If expressions test for errors.
  ;; Note the |err| capture on the else.

  (const ^anyerror!u32 a 0)
  (if a
    (bind value
      (expect (= value 0)))
    (bind err
      (unreachable)))

  (const ^anyerror!u32 b error.BadValue)
  (if b
    (bind value (unreachable))
    (bind err
      (expect (= err error.BadValue))))

  ;; The else and |err| capture is strictly required.
  (if a
    (bind value
      (expect (= value 0)))
    (bind _))

  ;; To check only the error value use an empty block expression.
  (if b
    (bind _)
    (bind err
      (expect (= err error.BadValue))))

  ;; Access the value by reference using a pointer capture.
  (var ^anyerror!u32 c 3)
  (if c
    (bind *value
      (set! value.* 9))
    (bind err (unreachable)))

  (if c
    (bind value
      (expect (= value 9)))
    (bind err (unreachable))))

(test "if error union with optional"
  ;; If expressions test for errors before unwrapping optionals.
  ;; The |optional_value| capture's type is ?u32.

  (const ^anyerror!?u32 a 0)
  (if a
    (bind optional_value
      (expect (= optional_value.? 0)))
    (bind err (unreachable)))

  (const ^anyerror!?u32 b nil)
  (if b
    (bind optional_value
      (expect (= optional_value nil)))
    (bind err (unreachable)))

  (const ^anyerror!?u32 c error.BadValue)
  (if c
    (bind optional_value (unreachable))
    (bind err
      (expect (= err error.BadValue))))

  ;; Access the value by reference by using a pointer capture each time.
  (var ^anyerror!?u32 d 3)
  (if d
    (bind *optional_value
      ;; Workaround wrapping with `do` to emit extra curly braces
      (do
        (if optional_value.*
          (bind *value
            (set! value.* 9)))))
    (bind err (unreachable)))

  (if d
    (bind optional_value
      (expect (= optional_value.? 9)))
    (bind err (unreachable))))

;; == test defer
(const std (@import "std"))
(const expect std.testing.expect)
(const print std.debug.print)

;; defer will execute an expression at the end of the current scope.
(defn ^usize deferExample []
  (var ^usize a 1)

  (do
    (defer (set! a 2))
    (set! a 1))
  (expect (= a 2))

  (set! a 5)
  (return a))

(test "defer basics"
  (expect (= (deferExample) 5)))

;; If multiple defer statements are specified, they will be executed in
;; the reverse order they were run.
(defn ^void deferUnwindExample []

  (defer
     (print "1 " []))
  (defer
     (print "2 " []))

  (if false
    ;; defers are not run if they are never executed.
    (do (defer
            (print "3 " [])))))

(test "defer unwinding"
  (deferUnwindExample))

;; The errdefer keyword is similar to defer, but will only execute if the
;; scope returns with an error.
;;
;; This is especially useful in allowing a function to clean up properly
;; on error, and replaces goto error handling tactics as seen in c.
(defn ^!void deferErrorExample [^bool is_error]
  (print "start of function\n" [])

  ;; This will always be executed on exit
  (defer
    (print "end of function\n" []))

  (errdefer
    (print "encountered an error!\n" []))

  (if is_error
    (return error.DeferError)))

(test "errdefer unwinding"
  (try (deferErrorExample false) (catch _ _))
  (try (deferErrorExample true) (catch _ _)))

;; == test functions
(const expect (.. (@import "std") -testing -expect))

;; Functions are declared like this
(defn ^i8 add [^i8 a ^i8 b]
  (when (= a 0)
      (return b))

  (return (+ a b)))

;; The export specifier makes a function externally visible in the generated
;; object file, and makes it use the C ABI.
(defn ^:export ^i8 sub [^i8 a ^i8 b] (return (- a b)))

;; The extern specifier is used to declare a function that will be resolved
;; at link time, when linking statically, or at runtime, when linking
;; dynamically.
;; The callconv specifier changes the calling convention of the function.
(defn ^{:extern "kernel32"} ^"callconv(.Stdcall) noreturn" ExitProcess [^u32 exit_code])

(defn ^{:extern "c"} ^f64 atan2 [^f64 a ^f64 b])

;; The @setCold builtin tells the optimizer that a function is rarely called.
(defn ^noreturn abort []
  (@setCold true)
  (while true))

;; The naked calling convention makes a function not have any function prologue or epilogue.
;; This can be useful when integrating with assembly.
(defn ^"callconv(.Naked) noreturn" _start []
  (abort))

;; The inline specifier forces a function to be inlined at all call sites.
;; If the function cannot be inlined, it is a compile-time error.
(defn ^:inline ^u32 shiftLeftOne [^u32 a]
  (return (<< a 1)))

;; The pub specifier allows the function to be visible when importing.
;; Another file can use @import and call sub2
(defn ^:pub ^i8 sub2 [^i8 a ^i8 b] (return (- a b)))

;; Functions can be used as values and are equivalent to pointers.
(const call2_op (^i8 fn [^i8 a ^i8 b]))
(defn ^i8 do_op [^call2_op fn_call ^i8 op1 ^i8 op2]
  (return (fn_call op1 op2)))

(test "function"
  (expect (= (do_op add 5 6) 11))
  (expect (= (do_op sub2 5 6) -1)))

;; == test Errors
(const std (@import "std"))

(const FileOpenError
  (error AccessDenied
         OutOfMemory
         FileNotFound))

(const AllocationError
  (error OutOfMemory))

(test "coerce subset to superset"
  (const err (foo AllocationError.OutOfMemory))
  (.expect std.testing (= err FileOpenError.OutOfMemory)))

(defn ^FileOpenError foo [^AllocationError err]
  (return err))

;; == test usingnamespace
(usingnamespace (@import "std"))

(test "using std namespace"
  (.expect testing true))

;; == test async suspend
(const std (@import "std"))
(const expect std.testing.expect)

(var ^i32 x 1)

(test "suspend with no resume"
  (var frame (async (func)))
  (expect (= x 2)))

(defn ^void func []
  (+= x 1)
  (suspend)
  ;; This line is never reached because the suspend has no matching resume.
  (+= x 1))

;; == test async suspend resume
(const std (@import "std"))
(const expect std.testing.expect)

(var ^anyframe the_frame undefined)
(var result false)

(test "async function suspend with block"
  (set! _ (async (testSuspendBlock)))
  (expect (not result))
  (resume the_frame)
  (expect result))

(defn ^void testSuspendBlock []
  (suspend
    (comptime (expect (= (@TypeOf (@frame)) (* (@Frame testSuspendBlock)))))
    (set! the_frame (@frame)))
  (set! result true))

;; == test async Resuming from Suspend Blocks
(const std (@import "std"))
(const expect std.testing.expect)

(test "resume from suspend"
  (var ^i32 my_result 1)
  (set! _ (async (testResumeFromSuspend (& my_result))))
  (.expect std.testing (= my_result 2)))

(defn ^void testResumeFromSuspend [^*i32 my_result]
  (suspend
    (resume (@frame)))
  (+= my_result.* 1)
  (suspend)
  (+= my_result.* 1))

;; == test async await
(const std (@import "std"))
(const expect std.testing.expect)

(test "async and await"
  ;; Here we have an exception where we do not match an async
  ;; with an await. The test block is not async and so cannot
  ;; have a suspend point in it.
  ;; This is well-defined behavior, and everything is OK here.
  ;; Note however that there would be no way to collect the
  ;; return value of amain, if it were something other than void.
  (set! _ (async (amain))))

(defn ^void amain []
  (var frame (async (func)))
  (comptime (expect (= (@TypeOf frame) (@Frame func))))

  (const ^anyframe->void ptr (& frame))
  (const ^anyframe any_ptr ptr)

  (resume any_ptr)
  (await ptr))

(defn ^void func []
  (suspend))

;; == test async function await
(const std (@import "std"))
(const expect std.testing.expect)

(var ^anyframe the_frame undefined)
(var ^i32 final_result 0)

(test "async function await"
  (seq \a)
  (set! _ (async (amain)))
  (seq \f)
  (resume the_frame)
  (seq \i)
  (expect (= final_result 1234))
  (expect (.eql std.mem u8 (& seq_points) "abcdefghi")))

(defn ^void amain []
  (seq \b)
  (var f (async (another)))
  (seq \e)
  (set! final_result (await f))
  (seq \h))

(defn ^i32 another []
  (seq \c)
  (suspend
    (seq \d)
    (set! the_frame (@frame)))
  (seq \g)
  (return 1234))

(var seq_points (** ^"[_]u8"[0]
                     (.-len "abcdefghi")))
(var ^usize seq_index 0)

(defn ^void seq [^u8 c]
  (aset seq_points seq_index c)
  (+= seq_index 1))

;; == run Async Function Example
(const std (@import "std"))
(const Allocator std.mem.Allocator)

(defn ^:pub ^void main []
  (set! _ (async (amainWrap)))

  ;; Typically we would use an event loop to manage resuming async functions
  ;; but in this example we hard code what the event loop would do
  ;; to make things deterministic.
  (resume global_file_frame)
  (resume global_download_frame))

(defn ^void amainWrap []
  (try (amain)
    (catch _ e
      (.print std.debug "{}\n" [e])
      (if (@errorReturnTrace)
        (bind trace
          (.dumpStackTrace std.debug trace.*)))
      (.exit std.process 1))))

(defn ^!void amain []
  (const allocator std.heap.page_allocator)
  (var download_frame (async (fetchUrl allocator "https://example.com/")))
  (var awaited_download_frame false)
  (errdefer (if (not awaited_download_frame)
              (if (await download_frame)
                (bind r (.free allocator r))
                (bind _))))

  (var file_frame (async (readFile allocator "something.txt")))
  (var awaited_file_frame false)
  (errdefer (if (not awaited_file_frame)
              (if (await file_frame)
                (bind r (.free allocator r))
                (bind _))))

  (set! awaited_file_frame true)
  (const file_text (try (await file_frame)))
  (defer (.free allocator file_text))

  (set! awaited_download_frame true)
  (const download_text (try (await download_frame)))
  (defer (.free allocator download_text))

  (.print std.debug "download_text: {}\n" [download_text])
  (.print std.debug "file_text: {}\n" [file_text]))

(var ^anyframe global_download_frame undefined)
(defn ^"![]u8" fetchUrl [^*Allocator allocator ^"[]const u8" url]
  (const result (try (.dupe std.mem allocator u8 "this is the downloaded url contents")))
  (errdefer (.free allocator result))
  (suspend (set! global_download_frame (@frame)))
  (.print std.debug "fetchUrl returning\n" [])
  (return result))

(var ^anyframe global_file_frame undefined)
(defn ^"![]u8" readFile [^*Allocator allocator ^"[]const u8" filename]
  (const result (try (.dupe std.mem allocator u8 "this is the file contents")))
  (errdefer (.free allocator result))
  (suspend (set! global_file_frame (@frame)))
  (.print std.debug "readFile returning\n" [])
  (return result))

;; == run Blocking Function Example
(const std (@import "std"))
(const Allocator std.mem.Allocator)

(defn ^:pub ^void main []
  (set! _ (async (amainWrap))))

(defn ^void amainWrap []
  (try (amain)
    (catch _ e
      (.print std.debug "{}\n" [e])
      (if (@errorReturnTrace)
        (bind trace
          (.dumpStackTrace std.debug trace.*)))
      (.exit std.process 1))))

(defn ^!void amain []
  (const allocator std.heap.page_allocator)
  (var download_frame (async (fetchUrl allocator "https://example.com/")))
  (var awaited_download_frame false)
  (errdefer (if (not awaited_download_frame)
              (if (await download_frame)
                (bind r (.free allocator r))
                (bind _))))

  (var file_frame (async (readFile allocator "something.txt")))
  (var awaited_file_frame false)
  (errdefer (if (not awaited_file_frame)
              (if (await file_frame)
                (bind r (.free allocator r))
                (bind _))))

  (set! awaited_file_frame true)
  (const file_text (try (await file_frame)))
  (defer (.free allocator file_text))

  (set! awaited_download_frame true)
  (const download_text (try (await download_frame)))
  (defer (.free allocator download_text))

  (.print std.debug "download_text: {}\n" [download_text])
  (.print std.debug "file_text: {}\n" [file_text]))

(defn ^"![]u8" fetchUrl [^*Allocator allocator ^"[]const u8" url]
  (const result (try (.dupe std.mem allocator u8 "this is the downloaded url contents")))
  (errdefer (.free allocator result))
  (.print std.debug "fetchUrl returning\n" [])
  (return result))

(var ^anyframe global_file_frame undefined)
(defn ^"![]u8" readFile [^*Allocator allocator ^"[]const u8" filename]
  (const result (try (.dupe std.mem allocator u8 "this is the file contents")))
  (errdefer (.free allocator result))
  (.print std.debug "readFile returning\n" [])
  (return result))

;; == test Pointers allowzero
(const std (@import "std"))
(const expect std.testing.expect)

(test "allowzero"
  (var ^usize zero 0)
  (var ptr (@intToPtr (zig* "*allowzero i32") zero))
  (expect (= (@ptrToInt ptr) 0)))
